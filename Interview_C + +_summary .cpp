1.说一下static关键字的作用

	1）全局静态变量

	在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。

	静态存储区，在整个程序运行期间一直存在。

	初始化：未经初始化的额全局静态变量会被自动初始化为0.

	作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

	2）局部静态变量

	在局部变量前加上关键字static，局部变量就定义成一个局部静态变量。

	内存中的位置：静态存储区

	初始化：未经初始化的额全局静态变量会被自动初始化为0.(自动对象的值是任意的，除非他被显式初始化)

	作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然
	驻留在内存中，只不过我们不能在对它进行访问，直到该函数再次被调用，并且值不变。

	3）静态函数

	在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是external的，但静态函数只是在声明他的文件中可见，不能被其他文件所用。

	函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突。

	Warning : 不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，
	如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需要加上static修饰。

	4）类的静态成员

	在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员式类的所有对象中共享的成员，
	而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。

	5）类的静态函数

	静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要对象名。

	在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。
	如果静态成员函数中要引用非静态成员时，可通过对象来引用。


	对于函数定义和代码块之外的变量声明，static修改标识符的链接属性，由默认的external变为internal，作用域和存储类型不改变，
	这些符号只能在声明它们的源文件中访问。
	
	对于代码块内部的变量声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。
	这种变量在程序执行之前就创建，在程序执行的整个周期都存在。

	对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用

	对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过<类名>::<静态成员>来使用。


2.说一下C++和C的区别

	1）在设计思想上

	C++是面向对象的语言，而C是面向过程的结构化编程语言。

	2）语法上

	C++ 具有封装、继承、和多态三种特性

	C++相比C,增加多许多类型安全的功能，比如强制类型转换

	C++支持范式编程，比如模板类、函数模板等


3.C++中四种cast转换

	C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast

	(1) const_cast

	用于将const变量转为非const

	(2) static_cast

  用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；

	(3) dynamic_cast

	用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，
	如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。

	向上转换：指的是子类向基类的转换

	向下转换：指的是基类向子类的转换

	它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

	(4) reinterpret_cast

	几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；

	(5) 为什么不使用C的强制转换？

	C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。


4.strcpy会从源地址一直往后拷贝，直到遇到'\0'为止。所以拷贝的长度是不定的。如果一直没有遇到'\0'导致越界访问非法内存，程序就崩了。
  
  strlen的结果未统计'\0'所占用的1个字节。

  写出一个完整版的strcpy函数
  char* strcpy(char *strDest, const char *strSrc) {
  	assert((strDest != NULL) && (strSrc != NULL));

  	char *address = strDest;

  	while((*strDest++ = *strSrc++) != '\0');

  	return adress;
  }

  有malloc ,必须有对应的free。 char *str = (char *)malloc(100)

  有[],必须有delete[]。

  申请内存结束后要进行内存是是否申请成功的判断。

  初始化int *p /= NULL都不对，p还是一个野指针，没有自己指向的内存，如果非要用int *p的话，要给p  分配个一个内存，记得释放掉。

  分别给出bool,int ,float,指针变量与"零值"比较的if语句
  bool类型：if(!var)
  int型变量：if(var == 0)
  float型变量： 
  	const float EPSINON = 0.00001;
  	if((x >= -EPSINON) && (x <= EPSINON))
  指针变量：if(var == NULL)


5.请写一个C函数，若处理器是Big_endian的，则返回0；若是Little_endian的，则返回1

	int checkCPU() {
		{
			union w
			{ 
				int a;
				char b;
			} c; 
			c.a = 1;
			return (c.b == 1);
		}
	}

	嵌入式系统开发者应该对Little-endian和Big-endian模式非常了解。
	采用Little-endian模式的CPU对操作数的存放方式是从低字节到高字节，而Big-endian模式对操作数的存放方式是从高字节到低字节。

	联合体union的存放顺序是所有成员都从低地址开始存放，面试者的解答利用该特性，轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写。


6.static关键字至少有下列n个作用：   
	（1）函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；   
	（2）在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；   
	（3）在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；   
	（4）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；   
	（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。    
const关键字至少有下列n个作用：   
	（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；   
	（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；   
	（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；   
	（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的 成员变量；   
	（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：   
	const classA operator*(const classA& a1,const classA& a2);   
	operator*的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错：   
	classA a, b, c;   
	(a * b) = c; // 对a*b的结果赋值   
	操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。


7.请说一下C/C++ 中指针和引用的区别？

	(1)指针有自己的一块空间，而引用只是一个别名；
	
	(2)使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；

	(3)指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；

	(4)作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；

 	(5)可以有const指针，但是没有const引用；

	(6)指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；

	(7)指针可以有多级指针（**p），而引用至于一级；

	(8)指针和引用使用++运算符的意义不一样；

	(9)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露.


8.请你说一下你理解的c++中的smart pointer四个智能指针：shared_ptr,unique_ptr,weak_ptr,auto_ptr

	智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。
	当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。
	C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。
	该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。
	对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。
	可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。

	野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针。









	



