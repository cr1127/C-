1.说一下static关键字的作用

	1）全局静态变量

	在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。

	静态存储区，在整个程序运行期间一直存在。

	初始化：未经初始化的全局静态变量会被自动初始化为0.

	作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

	2）局部静态变量

	在局部变量前加上关键字static，局部变量就定义成一个局部静态变量。

	内存中的位置：静态存储区

	初始化：未经初始化的局部静态变量会被自动初始化为0.(自动对象的值是任意的，除非他被显式初始化)

	作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然
	驻留在内存中，只不过我们不能在对它进行访问，直到该函数再次被调用，并且值不变。

	3）静态函数

	在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是external的，但静态函数只是在声明他的文件中可见，不能被其他文件所用。

	函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突。

	Warning : 不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，
	如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需要加上static修饰。

	4）类的静态成员

	在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员式类的所有对象中共享的成员，
	而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。

	5）类的静态函数

	静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要对象名。

	在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。
	如果静态成员函数中要引用非静态成员时，可通过对象来引用。


	对于函数定义和代码块之外的变量声明，static修改标识符的链接属性，由默认的external变为internal，作用域和存储类型不改变，
	这些符号只能在声明它们的源文件中访问。
	
	对于代码块内部的变量声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。
	这种变量在程序执行之前就创建，在程序执行的整个周期都存在。

	对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用

	对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过<类名>::<静态成员>来使用。


2.说一下C++和C的区别

	1）在设计思想上

	C++是面向对象的语言，而C是面向过程的结构化编程语言。

	2）语法上

	C++ 具有封装、继承、和多态三种特性

	C++相比C,增加多许多类型安全的功能，比如强制类型转换

	C++支持范式编程，比如模板类、函数模板等


3.C++中四种cast转换

	C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast

	(1) const_cast

	用于将const变量转为非const

	(2) static_cast

  用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；

	(3) dynamic_cast

	用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，
	如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。

	向上转换：指的是子类向基类的转换

	向下转换：指的是基类向子类的转换

	它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

	(4) reinterpret_cast

	几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；

	(5) 为什么不使用C的强制转换？

	C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。


4.strcpy会从源地址一直往后拷贝，直到遇到'\0'为止。所以拷贝的长度是不定的。如果一直没有遇到'\0'导致越界访问非法内存，程序就崩了。
  
  strlen的结果未统计'\0'所占用的1个字节。

  写出一个完整版的strcpy函数
  char* strcpy(char *strDest, const char *strSrc) {
  	assert((strDest != NULL) && (strSrc != NULL));

  	char *address = strDest;

  	while((*strDest++ = *strSrc++) != '\0');

  	return adress;
  }

  有malloc ,必须有对应的free。 char *str = (char *)malloc(100)

  有[],必须有delete[]。

  申请内存结束后要进行内存是是否申请成功的判断。

  初始化int *p /= NULL都不对，p还是一个野指针，没有自己指向的内存，如果非要用int *p的话，要给p  分配个一个内存，记得释放掉。

  分别给出bool,int ,float,指针变量与"零值"比较的if语句
  bool类型：if(!var)
  int型变量：if(var == 0)
  float型变量： 
  	const float EPSINON = 0.00001;
  	if((x >= -EPSINON) && (x <= EPSINON))
  指针变量：if(var == NULL)


5.请写一个C函数，若处理器是Big_endian的，则返回0；若是Little_endian的，则返回1

	int checkCPU() {
		{
			union w
			{ 
				int a;
				char b;
			} c; 
			c.a = 1;
			return (c.b == 1);
		}
	}

	嵌入式系统开发者应该对Little-endian和Big-endian模式非常了解。
	采用Little-endian模式的CPU对操作数的存放方式是从低字节到高字节，而Big-endian模式对操作数的存放方式是从高字节到低字节。

	联合体union的存放顺序是所有成员都从低地址开始存放，面试者的解答利用该特性，轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写。


6.static关键字至少有下列n个作用：   
	（1）函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；   
	（2）在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；   
	（3）在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；   
	（4）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；   
	（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。    
const关键字至少有下列n个作用：   
	（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；   
	（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；   
	（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；   
	（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的 成员变量；   
	（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：   
	const classA operator*(const classA& a1,const classA& a2);   
	operator*的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错：   
	classA a, b, c;   
	(a * b) = c; // 对a*b的结果赋值   
	操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。


7.请说一下C/C++ 中指针和引用的区别？

	(1)指针有自己的一块空间，而引用只是一个别名；
	
	(2)使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；

	(3)指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；

	(4)作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；

 	(5)可以有const指针，但是没有const引用；

	(6)指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；

	(7)指针可以有多级指针（**p），而引用至于一级；

	(8)指针和引用使用++运算符的意义不一样；

	(9)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露.


8.请你说一下你理解的c++中的smart pointer四个智能指针：shared_ptr,unique_ptr,weak_ptr,auto_ptr

	智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。
	当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。
	C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。
	该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。
	对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。
	可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。

	野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针。


9.数组和指针的区别

	                 指针                                             数据

	            保存数据的地址                                       保存数据
	
	间接访问数据，首先获得指针得内容，然后将其作为地址，            直接访问数据
	从该地址中提取数据

	           通常用于动态的数据结构                         通常用于固定数目且数据类型相同的元素

	           通过malloc分配内存，free释放内存                  隐式的分配和删除

	           通常指向匿名数据，操作匿名函数                        自身即为数据名


10.请你回答以下智能指针有没有内存泄漏的情况

	当两个对象相互使用一个shared_prt成员变量指向对方，会造成循环引用，使引用技术失效，从而导致内存泄漏。
	自己实践下


11.请你来说一下智能指针的内存泄漏如何解决

	为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，
	其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。


12.请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数

	将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，
	释放基类指针时可以释放掉子类的空间，防止内存泄漏。

	C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其
	析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。


13.请你来说一下函数指针

	(1)定义

		函数指针是指向函数的指针变量。

		函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。

		C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，
		就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。

	(2)用途：

		调用函数和做函数的参数，比如回调函数。

	(3)示例：

		char * fun(char * p)  {…}       // 函数fun
		char * (*pf)(char * p);             // 函数指针pf
		pf = fun;                        // 函数指针pf指向函数fun
		pf(p);                        // 通过函数指针pf调用函数fun


14.请你来说一下fork函数

	Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：
	
	#include <sys/types.h>
	#include <unistd.h>
	pid_t fork(void);

	成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。
	在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。

	最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。
	这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。

	在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，
	然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。
	现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。


15.请你来说一下C++中析构函数的作用

	析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。
	
	析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如~stud( )，以区别于构造函数。
	它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。

	如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，
	并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），
	它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。

	如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

	类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。


16.请你来说一下map和set有什么区别，分别又是怎么实现的？

	map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，
	所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。

	map和set区别在于：

		1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；
		Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。

		2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。
		其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，
		然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，
		不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；
		而map的迭代器则不允许修改key值，允许修改value值。

		3）map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，
		如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，
		因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，
		mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。


17.请你来介绍一下STL的allocaotr

	STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：
	
	new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容

	delete运算分两个阶段：(1)调用对象希构函数；(2)掉员工::operator delete释放内存

	为了精密分工，STL allocator将两个阶段操作区分开来：内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；
	对象构造由::construct()负责，对象析构由::destroy()负责。

	同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，
	会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。
	第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，
	而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。


18.请你来说一下C++中类成员的访问权限

	C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，
	它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），
	无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。
	在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。


19.请你来说一下C++中struct和class的区别

	在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，
	而class的默认继承权限和默认访问权限是private。另外，class还可以定义模板类形参，比如template <class T, int i>。


20.请你来说一下一个C++源文件从文本到可执行文件经历的过程？

	对于C++源文件，从文本到可执行文件一般需要四个过程：
	
	预处理阶段（.c—.i）：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。

	编译阶段（.i—.s）：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件

	汇编阶段（.s—.o）：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件

	链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件


21.请你来回答一下include头文件的顺序以及双引号””和尖括号<>的区别？

	Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。
	那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。
	
	双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。

	对于使用双引号包含的头文件，查找头文件路径的顺序为：

	当前头文件目录

	编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）

	系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径

	对于使用尖括号包含的头文件，查找头文件的路径顺序为：

	编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）

	系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径


22.请你来回答一下new和malloc的区别

	1）new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；
	
	2）new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。

	3）new不仅分配一段内存，而且会调用构造函数，malloc不会。

	4）new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。

	5）new是一个操作符可以重载，malloc是一个库函数。

	6）malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。

	7）new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。

	8）申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。
	而malloc则只能sizeof(int) * n。


23.请你来回答一下什么是memory leak，也就是内存泄漏

	内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，
	而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。
	
	内存泄漏的分类：

	1）堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，
	再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，
	那么此后这块内存将不会被使用，就会产生Heap Leak.

	2）系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，
	导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。

	3）没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，
	子类的资源没有正确是释放，因此造成内存泄露。


24.请你来说一下什么时候会发生段错误

	段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：
	
	使用野指针

	试图修改字符串常量的内容


25.请你回答一下如何判断内存泄漏？

	内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，
	我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能，
	统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。


26.请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？

	Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，
	然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。
	Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，
	即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。
	
	当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，
	根据每个块的前后块是否已经分配来决定是否进行块合并。

	Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；
	而当申请内存大于128K时，会使用系统函数mmap在映射区分配。


27.请你说一说C++的内存管理是怎样的？

	在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。
	
	代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。

	数据段：存储程序中已初始化的全局变量和静态变量

	bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。

	堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。

	映射区:存储动态链接库以及调用mmap函数进行的文件映射

	栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值


28.请你来说一下C++/C的内存分配

	32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0~3G是用户态空间，3~4G是内核空间，
	不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：

	各个段说明如下：

	3G用户空间和1G内核空间

	静态区域：

	text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。

	data segment(数据段)：存储程序中已初始化的全局变量和静态变量

	bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，
	对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0

	动态区域：

	heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，
	从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。

	memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）

	stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。
	在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。








	



